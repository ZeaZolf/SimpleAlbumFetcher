// lib/util.ts
function stripVariation(name) {
  return name.replace(/\s\(\d+\)$/, "");
}
function toQueryString(data) {
  if (!data || !Object.keys(data).length) {
    return "";
  }
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(data)) {
    searchParams.set(key, value.toString());
  }
  return "?" + searchParams.toString();
}
function escape(str) {
  return encodeURIComponent(str);
}
function merge(target, source) {
  for (const key in source) {
    const value = source[key];
    if (isObject(value)) {
      target[key] = merge(Array.isArray(value) ? [] : {}, value);
    } else {
      target[key] = value;
    }
  }
  return target;
}
function isObject(value) {
  return value && typeof value === "object";
}

// lib/client.ts
import fetch2, { Headers } from "node-fetch";

// lib/error.ts
var DiscogsError = class extends Error {
  /**
   * Discogs generic error
   * @param {number} [statusCode] - A HTTP status code
   * @param {string} [message] - The error message
   */
  constructor(statusCode, message) {
    super(message || "Unknown error.");
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
    this.statusCode = statusCode || 404;
  }
  toString() {
    return this.name + ": " + this.statusCode + " " + this.message;
  }
};
var AuthError = class extends DiscogsError {
  constructor() {
    super(401, "You must authenticate to access this resource.");
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};

// lib/database.ts
function database_default(client) {
  return {
    /**
     * Expose Discogs database status constants
     * @deprecated Use the `Status` enum instead
     */
    status: { accepted: "Accepted", draft: "Draft", deleted: "Deleted", rejected: "Rejected" },
    /**
     * Get artist data
     * @param {(number|string)} artist - The Discogs artist ID
     * @returns {Promise<RateLimitedResponse<GetArtistResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-artist-get
     *
     * @example
     * await client.database().getArtist(108713);
     */
    getArtist: function(artist) {
      return client.get("/artists/" + artist);
    },
    /**
     * Get artist release data
     * @param {(number|string)} artist - The Discogs artist ID
     * @param {PaginationParameters & SortParameters<'year'|'title'|'format'>} [params] - Optional pagination params
     * @returns {Promise<RateLimitedResponse<GetArtistReleasesResponses & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-artist-releases-get
     *
     * @example
     * await client.database().getArtistReleases(108713, { page: 2, sort: 'year', sort_order: 'asc' });
     */
    getArtistReleases: function(artist, params) {
      const path = `/artists/${artist}/releases${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Get release data
     * @param {(number|string)} release - The Discogs release ID
     * @param {Currency} [currency] - Currency for marketplace data. Defaults to the authenticated users currency.
     * @returns {Promise<RateLimitedResponse<GetReleaseResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-release-get
     *
     * @example
     * await client.database().getRelease(249504);
     *
     * @example
     * await client.database().getRelease(249504, 'USD');
     */
    getRelease: function(release, currency) {
      let path = `/releases/${release}`;
      if (currency !== void 0) {
        path += `${toQueryString({ curr_abbr: currency })}`;
      }
      return client.get(path);
    },
    /**
     * Get the release rating for the given user
     * @param {(number|string)} release - The Discogs release ID
     * @param {string} user - The Discogs user name
     * @returns {Promise<RateLimitedResponse<GetReleaseRatingResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user-get
     *
     * @example
     * await client.database().getReleaseRating(249504, 'rodneyfool');
     */
    getReleaseRating: function(release, user) {
      return client.get(`/releases/${release}/rating/${escape(user)}`);
    },
    /**
     * Set (or remove) a release rating for the given logged in user
     * @param {(number|string)} release - The Discogs release ID
     * @param {string} user - The Discogs user name
     * @param {1 | 2 | 3 | 4 | 5 | null} rating - The new rating for a release between 1 and 5. Null = remove rating
     * @returns {Promise<RateLimitedResponse<GetReleaseRatingResponse | void>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user-put
     * @see https://www.discogs.com/developers/#page:database,header:database-release-rating-by-user-delete
     *
     * @example
     * await client.database().setReleaseRating(249504, 'rodneyfool', 2);
     *
     * @example
     * await client.database().setReleaseRating(249504, 'rodneyfool', null);
     */
    setReleaseRating: function(release, user, rating) {
      const url = `/releases/${release}/rating/${escape(user)}`;
      if (!rating) {
        return client.delete({ url, authLevel: 2 });
      } else {
        return client.put({ url, authLevel: 2 }, { rating: rating > 5 ? 5 : rating });
      }
    },
    /**
     * Get the average rating and the total number of user ratings for a given release.
     * @param {(number|string)} release - The Discogs release ID
     * @returns {Promise<RateLimitedResponse<GetReleaseCommunityRatingResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-community-release-rating-get
     *
     * @example
     * await client.database().getReleaseCommunityRating(249504);
     */
    getReleaseCommunityRating: function(release) {
      const path = `/releases/${release}/rating`;
      return client.get(path);
    },
    /**
     * Get the total number of "haves" (in the community's collections)
     * and "wants" (in the community's wantlists) for a given release.
     * @param {(number|string)} release - The Discogs release ID
     * @returns {Promise<RateLimitedResponse<GetReleaseStatsResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-release-stats-get
     *
     * @example
     * await client.database().getReleaseStats(249504);
     */
    getReleaseStats: function(release) {
      const path = `/releases/${release}/stats`;
      return client.get(path);
    },
    /**
     * Get master release data
     * @param {(number|string)} master - The Discogs master release ID
     * @returns {Promise<RateLimitedResponse<GetMasterResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-master-release-get
     *
     * @example
     * await client.database().getMaster(1000);
     */
    getMaster: function(master) {
      return client.get(`/masters/${master}`);
    },
    /**
     * Get the release versions contained in the given master release
     * @param {(number|string)} master - The Discogs master release ID
     * @param {PaginationParameters & Partial<{ format: string; label: string; released: string; country: string } & SortParameters<'released'|'title'|'format'|'label'|'catno'|'country'>>} [params] - optional pagination params
     * @returns {Promise<RateLimitedResponse<GetMasterVersionsResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-master-release-versions-get
     *
     * @example
     * await client.database().getMasterVersions(1000, {
     *     page: 2,
     *     per_page: 25,
     *     format: 'Vinyl',
     *     label: 'Scorpio Music',
     *     released: '1992',
     *     country: 'Belgium',
     *     sort: 'released',
     *     sort_order: 'asc'
     * });
     */
    getMasterVersions: function(master, params) {
      const path = `/masters/${master}/versions${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Get label data
     * @param {(number|string)} label - The Discogs label ID
     * @returns {Promise<RateLimitedResponse<GetLabelResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-label-get
     *
     * @example
     * await client.database().getLabel(1)
     */
    getLabel: function(label) {
      return client.get(`/labels/${label}`);
    },
    /**
     * Get label release data
     * @param {(number|string)} label - The Discogs label ID
     * @param {PaginationParameters} [params] - Optional pagination params
     * @returns {Promise<RateLimitedResponse<GetLabelReleasesResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-all-label-releases-get
     *
     * @example
     * await client.database().getLabelReleases(1, { page: 3, per_page: 25 });
     */
    getLabelReleases: function(label, params) {
      const path = `/labels/${label}/releases${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Search the database
     * @param {PaginationParameters & Partial<SearchParameters>} [params] - Search parameters
     *
     * @returns {Promise<RateLimitedResponse<SearchResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:database,header:database-search-get
     *
     * @example
     * await client.database().search({
     *     query: 'nirvana', // Your search query
     *     type: 'release', // One of 'release', 'master', 'artist', 'label'
     *     title: 'nirvana - nevermind', // Search by combined “Artist Name - Release Title” title field.
     *     release_title: 'nevermind', // Search release titles.
     *     credit: 'kurt', // Search release credits.
     *     artist: 'nirvana', // Search artist names.
     *     anv: 'nirvana', // Search artist ANV.
     *     label: 'dgc', // Search label names.
     *     genre: 'rock', // Search genres.
     *     style: 'grunge', // Search styles.
     *     country: 'canada', // Search release country.
     *     year: '1991', // Search release year.
     *     format: 'album', // Search formats.
     *     catno: 'DGCD-24425', // Search catalog number.
     *     barcode: '7 2064-24425-2 4', // Search barcodes.
     *     track: 'smells like teen spirit', // Search track titles.
     *     submitter: 'milKt', // Search submitter username.
     *     contributor: 'jerome99', // Search contributor usernames.
     * });
     */
    search: function(params = {}) {
      const { query, ...inputArgs } = params;
      const args = query ? Object.assign(inputArgs, { q: query }) : inputArgs;
      return client.get({ url: `/database/search${toQueryString(args)}`, authLevel: 1 });
    }
  };
}

// lib/collection.ts
function collection_default(client) {
  return {
    /**
     * Get a list of all collection folders for the given user
     * @param {string} user - The user name
     * @returns {Promise<RateLimitedResponse<GetFoldersResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-get
     *
     * @example
     * await client.user().collection().getFolders('rodneyfool');
     */
    getFolders: function(user) {
      return client.get(`/users/${escape(user)}/collection/folders`);
    },
    /**
     * Get metadata for a specified collection folder
     * @param {string} user - The Discogs user name
     * @param {number | string} folder - A folder ID (0 = public folder)
     * @returns {Promise<RateLimitedResponse<GetFolderResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder-get
     *
     * @example
     * await client.user().collection().getFolder('rodneyfool', 3);
     */
    getFolder: function(user, folder) {
      if (client.authenticated(2) || Number(folder) === 0) {
        return client.get(`/users/${escape(user)}/collection/folders/${folder}`);
      }
      return Promise.reject(new AuthError());
    },
    /**
     * Add a new collection folder
     * @param {string} user - The user name
     * @param {string} name - The folder name
     * @returns {Promise<RateLimitedResponse<GetFolderResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-post
     *
     * @example
     * await client.user().collection().addFolder('rodneyfool', 'My favorites');
     */
    addFolder: function(user, name) {
      return client.post(
        { url: `/users/${escape(user)}/collection/folders`, authLevel: 2 },
        { name }
      );
    },
    /**
     * Change a folder name. The name of folder 0 and 1 can't be changed.
     * @param {string} user - The user name
     * @param {(number|string)}	folder - The folder ID
     * @param {string} name - The new folder name
     * @returns {Promise<RateLimitedResponse<GetFolderResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-folder-post
     *
     * @example
     * await client.user().collection().setFolderName('rodneyfool', 3, 'New Name');
     */
    setFolderName: function(user, folder, name) {
      return client.post(
        { url: `/users/${escape(user)}/collection/folders/${folder}`, authLevel: 2 },
        { name }
      );
    },
    /**
     * Delete a folder. A folder must be empty before it can be deleted.
     * @param {string} user - The user name
     * @param {(number|string)}	folder - The folder ID
     * @returns {Promise<RateLimitedResponse<void>>>}
     *
     * @example
     * await client.user().collection().deleteFolder('rodneyfool', 3);
     */
    deleteFolder: function(user, folder) {
      return client.delete({
        url: `/users/${escape(user)}/collection/folders/${folder}`,
        authLevel: 2
      });
    },
    /**
     * Get the releases in a user's collection folder (0 = public folder)
     * @param {string} user - The user name
     * @param {(number|string)} folder - The folder ID
     * @param {PaginationParameters & SortParameters<'label'|'artist'|'title'|'catno'|'format'|'rating'|'added'|'year'>} [params] - Optional extra pagination and sorting params
     * @returns {Promise<RateLimitedResponse<GetReleasesResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-folder-get
     *
     * @example
     * await client.user().collection().getReleases('rodneyfool', 3, { sort: 'artist', sort_order: 'desc' });
     */
    getReleases: function(user, folder, params) {
      if (client.authenticated(2) || Number(folder) === 0) {
        const path = `/users/${escape(user)}/collection/folders/${folder}/releases${toQueryString(params)}`;
        return client.get(path);
      }
      return Promise.reject(new AuthError());
    },
    /**
     * Get the instances of a release in a user's collection
     * @param {string} user - The user name
     * @param {(number|string)} release - The release ID
     * @returns {Promise<RateLimitedResponse<GetReleaseInstancesResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-items-by-release-get
     *
     * @example
     * await client.user().collection().getReleaseInstances('susan.salkeld', 7781525);
     */
    getReleaseInstances: function(user, release) {
      return client.get(`/users/${escape(user)}/collection/releases/${release}`);
    },
    /**
     * Add a release instance to the (optionally) given collection folder
     * @param {string} user - The user name
     * @param {(number|string)} release - The release ID
     * @param {(number|string)} [folder] - The folder ID (defaults to the "Uncategorized" folder)
     * @returns {Promise<RateLimitedResponse<AddReleaseResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-add-to-collection-folder-post
     *
     * @example
     * await client.user().collection().addRelease('rodneyfool', 130076, 3);
     */
    addRelease: function(user, release, folder = 1) {
      return client.post(
        { url: `/users/${escape(user)}/collection/folders/${folder}/releases/${release}`, authLevel: 2 },
        void 0
      );
    },
    /**
     * Edit a release instance in the given collection folder
     * @param {string} user - The user name
     * @param {(number|string)} folder - The folder ID
     * @param {(number|string)} release - The release ID
     * @param {(number|string)} instance - The release instance ID
     * @param {Partial<{ rating: 1 | 2 | 3 | 4 | 5 | null; folder_id: number }>} data - The instance data
     * @returns {Promise<RateLimitedResponse<void>>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-change-rating-of-release-post
     *
     * @example
     * await client.user().collection().editRelease('rodneyfool', 4, 130076, 1, { rating: 5, folder_id: 16 });
     */
    editRelease: function(user, folder, release, instance, data) {
      return client.post(
        {
          url: `/users/${escape(
            user
          )}/collection/folders/${folder}/releases/${release}/instances/${instance}`,
          authLevel: 2
        },
        data
      );
    },
    /**
     * Remove an instance of a release from a user's collection folder.
     * @param {string} user - The user name
     * @param {(number|string)} folder - The folder ID
     * @param {(number|string)} release - The release ID
     * @param {(number|string)} instance - The release instance ID
     * @returns {Promise<RateLimitedResponse<void>>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-delete-instance-from-folder-delete
     *
     * @example
     * await client.user().collection().removeRelease('rodneyfool', 3, 130076, 1);
     */
    removeRelease: function(user, folder, release, instance) {
      return client.delete({
        url: `/users/${escape(user)}/collection/folders/${folder}/releases/${release}/instances/${instance}`,
        authLevel: 2
      });
    },
    /**
     * Retrieve a list of user-defined collection notes fields.
     * These fields are available on every release in the collection.
     * @param {string} user - The user name
     * @returns {Promise<RateLimitedResponse<GetFieldsResponse>>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-list-custom-fields-get
     *
     * @example
     * await client.user().collection().getFields('rodneyfool');
     */
    getFields: function(user) {
      return client.get(`/users/${escape(user)}/collection/fields`);
    },
    /**
     * Change the value of a notes field on a particular instance.
     * @param {string} user - The user name
     * @param {(number|string)} folder - The folder ID
     * @param {(number|string)} release - The release ID
     * @param {(number|string)} instance - The release instance ID
     * @param {number} field - The ID of the field
     * @param {string} value - The new value of the field
     * @returns {Promise<RateLimitedResponse<void>>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-edit-fields-instance-post
     *
     * @example
     * await client.user().collection().editInstanceNote('rodneyfool', 3, 130076, 1, 8, 'foo');
     */
    editInstanceNote: function(user, folder, release, instance, field, value) {
      const path = `/users/${escape(
        user
      )}/collection/folders/${folder}/releases/${release}/instances/${instance}/fields/${field}`;
      return client.post(path, { value });
    },
    /**
     * Returns the minimum, median, and maximum value of a user's collection
     * @param {string} user - The user name
     * @returns {Promise<RateLimitedResponse<CollectionValueResponse>>>}
     *
     * @see https://www.discogs.com/developers/#page:user-collection,header:user-collection-collection-value-get
     *
     * @example
     * await client.user().collection().getValue('rodneyfool');
     */
    getValue: function(user) {
      return client.get({ url: `/users/${escape(user)}/collection/value`, authLevel: 2 });
    }
  };
}

// lib/list.ts
function list_default(client) {
  return {
    /**
     * Get the items in a list by list ID
     * @param {(number|string)} list - The list ID
     * @returns {Promise<RateLimitedResponse<GetListItemsResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-lists,header:user-lists-list-get
     *
     * @example
     * await client.user().list().getItems(123)
     */
    getItems: function(list) {
      const path = `/lists/${escape(list.toString())}`;
      return client.get(path);
    }
  };
}

// lib/wantlist.ts
function wantlist_default(client) {
  return {
    /**
     * Get the list of wantlisted releases for the given user name
     * @param {string} user - The user name
     * @param {PaginationParameters} [params] - Optional pagination params
     * @returns {Promise<RateLimitedResponse<PaginationResponse & {wants: Array<WantlistEntryResponse>}>>}
     *
     * @see https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-wantlist-get
     *
     * @example
     * await client.user().wantlist().getReleases('rodneyfool', { page: 2, per_page: 4 });
     */
    getReleases: function(user, params) {
      const path = `/users/${escape(user)}/wants${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Add a release to the user's wantlist
     * @param {string} user - The user name
     * @param {(number|string)} release - The release ID
     * @param {{notes?: string, rating?: 0 | 1 | 2 | 3 | 4 | 5}} [data] - Optional notes and rating
     * @returns {Promise<RateLimitedResponse<WantlistEntryResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist-put
     *
     * @example
     * await client.user().wantlist().addRelease('rodneyfool', 130076, { notes: 'My favorite release', rating: 5 });
     */
    addRelease: function(user, release, data) {
      return client.put({ url: `/users/${escape(user)}/wants/${release}`, authLevel: 2 }, data);
    },
    /**
     * Edit the notes or rating on a release in the user's wantlist
     * @param {string} user - The user name
     * @param {(number|string)} release - The release ID
     * @param {{notes?: string, rating?: 0 | 1 | 2 | 3 | 4 | 5}} [data] - The notes and rating { notes: 'Test', rating: 4 }
     * @returns {Promise<RateLimitedResponse<WantlistEntryResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist-post
     *
     * @example
     * await client.user().wantlist().editNotes('rodneyfool', 130076, { notes: 'My favorite release', rating: 4 });
     */
    editNotes: function(user, release, data) {
      return client.post({ url: `/users/${escape(user)}/wants/${release}`, authLevel: 2 }, data);
    },
    /**
     * Remove a release from the user's wantlist
     * @param {string} user - The user name
     * @param {(number|string)} release - The release ID
     * @returns {Promise<RateLimitedResponse<void>>}
     *
     * @see https://www.discogs.com/developers/#page:user-wantlist,header:user-wantlist-add-to-wantlist-delete
     *
     * @example
     * await client.user().wantlist().removeRelease('rodneyfool', 130076);
     */
    removeRelease: function(user, release) {
      return client.delete({ url: `/users/${escape(user)}/wants/${release}`, authLevel: 2 });
    }
  };
}

// lib/user.ts
function user_default(client) {
  return {
    /**
     * Get the profile for the given user
     * @param {string} username - The user name
     * @returns {Promise<RateLimitedResponse<GetProfileResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile-get
     *
     * @example
     * await client.user().getProfile('rodneyfool');
     */
    getProfile: function(username) {
      return client.get(`/users/${escape(username)}`);
    },
    /**
     * Edit a user's profile data.
     * @param {string} username - The user name
     * @param {Partial<{ name: string; home_page: string; location: string; profile: string; curr_abbr: Currency}>} data - The profile data
     * @returns {Promise<RateLimitedResponse<GetProfileResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-identity,header:user-identity-profile-post
     *
     * @example
     * await client.user().editProfile('rodneyfool', {
     *     name: 'Nicolas Cage',
     *     home_page: 'www.discogs.com',
     *     location: 'Portland',
     *     profile: 'I am a Discogs user!',
     *     curr_abbr: 'USD',
     * });
     */
    editProfile: function(username, data) {
      return client.post(`/users/${escape(username)}`, data);
    },
    /**
     * Get the inventory for the given user
     * @param {string} user - The user name
     * @param {Partial<{status: string}> & PaginationParameters & SortParameters<'listed'|'price'|'item'|'artist'|'label'|'catno'|'audio'|'status'|'location'>} [params] - Extra params like status, sort and sort_order, pagination
     * @returns {Promise<RateLimitedResponse<GetInventoryResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-inventory
     *
     * @example
     * await client.user().getInventory('rodneyfool', { status: 'for sale', page: 3, per_page: 25, sort: 'status', sort_order: 'asc' });
     */
    getInventory: function(user, params) {
      const path = `/users/${escape(user)}/inventory${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Copy the client getIdentity function to the user module
     */
    getIdentity: client.getIdentity,
    /**
     * Expose the collection functions and pass the client instance
     * @returns {ReturnType<typeof collection>}
     */
    collection: function() {
      return collection_default(client);
    },
    /**
     * Expose the wantlist functions and pass the client instance
     * @returns {ReturnType<typeof wantlist>}
     */
    wantlist: function() {
      return wantlist_default(client);
    },
    /**
     * Expose the list functions and pass the client instance
     * @returns {ReturnType<list>}
     */
    list: function() {
      return list_default(client);
    },
    /**
     * Get the contributions for the given user
     * @param {string} user - The user name
     * @param {PaginationParameters & SortParameters<'label'|'artist'|'title'|'catno'|'format'|'rating'|'year'|'added'>} [params] - Optional pagination and sorting params
     * @returns {Promise<RateLimitedResponse<GetContributionsResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-contributions-get
     *
     * @example
     * await client.user().getContributions('rodneyfool', {
     *     page: 2,
     *     per_page: 50,
     *     sort: 'artist',
     *     sort_order: 'desc'
     * });
     */
    getContributions: function(user, params) {
      const path = `/users/${escape(user)}/contributions${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Get the submissions for the given user
     * @param {string} user - The user name
     * @param {PaginationParameters} [params] - Optional pagination params
     * @returns {Promise<RateLimitedResponse<PaginationResponse & GetSubmissionsResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-identity,header:user-identity-user-submissions-get
     *
     * @example
     * await client.user().getSubmissions('rodneyfool', { page: 2, per_page: 100 });
     */
    getSubmissions: function(user, params) {
      const path = `/users/${escape(user)}/submissions${toQueryString(params)}`;
      return client.get(path);
    },
    /**
     * Get the lists for the given user
     * @param {string} user - The user name
     * @param {PaginationParameters} [params] - Optional pagination params
     * @returns {Promise<RateLimitedResponse<PaginationResponse & GetListsResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-lists,header:user-lists-user-lists-get
     *
     * @example
     * await client.user().getLists('rodneyfool', { page: 3, per_page: 25 });
     */
    getLists: function(user, params) {
      const path = `/users/${escape(user)}/lists${toQueryString(params)}`;
      return client.get(path);
    }
  };
}

// lib/marketplace.ts
function marketplace_default(client) {
  return {
    /**
     * Copy the getInventory function from the user module
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-inventory-get
     */
    getInventory: user_default(client).getInventory,
    /**
     * Get a marketplace listing
     * @param {number} listing - The listing ID
     * @param {Currency} [currency] - Optional currency
     * @returns {Promise<RateLimitedResponse<Listing>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing-get
     *
     * @example
     * await client.marketplace().getListing(172723812, 'USD');
     */
    getListing: function(listing, currency) {
      let path = `/marketplace/listings/${listing}`;
      if (currency !== void 0) {
        path += `${toQueryString({ curr_abbr: currency })}`;
      }
      return client.get(path);
    },
    /**
     * Create a marketplace listing
     * @param {{release_id: number; condition: Condition; price: number; status: SaleStatus;} & Partial<{sleeve_condition: SleeveCondition; comments: string; allow_offers: boolean; external_id: string; location: string; weight: number | 'auto'; format_quantity: number | 'auto'}>} data - The data for the listing
     * @returns {Promise<RateLimitedResponse<AddListingResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-new-listing-post
     *
     * @example
     * await client.marketplace().addListing({
     *     release_id: 1,
     *     condition: 'Mint (M)',
     *     sleeve_condition: 'Fair (F)',
     *     price: 10,
     *     comments: 'This item is wonderful',
     *     allow_offers: true,
     *     status: 'Draft',
     *     external_id: '1234321',
     *     location: 'top shelf',
     *     weight: 200,
     *     format_quantity: 'auto',
     * });
     */
    addListing: function(data) {
      return client.post({ url: "/marketplace/listings", authLevel: 2 }, data);
    },
    /**
     * Edit a marketplace listing
     * @param {number} listing - The listing ID
     * @param {{release_id: number; condition: Condition; price: number; status: SaleStatus} & Partial<{sleeve_condition: SleeveCondition; comments: string; allow_offers: boolean; external_id: string; location: string; weight: number | 'auto'; format_quantity: number | 'auto'}>} data - The data for the listing
     * @returns {Promise<RateLimitedResponse<void>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing-post
     *
     * @example
     * await client.marketplace().editListing(172723812, {
     *     release_id: 1,
     *     condition: 'Mint (M)',
     *     sleeve_condition: 'Fair (F)',
     *     price: 10,
     *     comments: 'This item is wonderful',
     *     allow_offers: true,
     *     status: 'Draft',
     *     external_id: '1234321',
     *     location: 'top shelf',
     *     weight: 200,
     *     format_quantity: 'auto',
     * });
     */
    editListing: function(listing, data) {
      return client.post({ url: `/marketplace/listings/${listing}`, authLevel: 2 }, data);
    },
    /**
     * Delete a marketplace listing
     * @param {number} listing - The listing ID
     * @returns {Promise<RateLimitedResponse<void>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-listing-delete
     *
     * @example
     * await client.marketplace().deleteListing(172723812);
     */
    deleteListing: function(listing) {
      return client.delete({ url: `/marketplace/listings/${listing}`, authLevel: 2 });
    },
    /**
     * Get a list of the authenticated user's orders
     * @param {Partial<{status: OrderStatus; created_after: string; created_before: string; archived: boolean}> & PaginationParameters & SortParameters<'id' | 'buyer' | 'created' | 'status' | 'last_activity'>} [params] - Optional sorting and pagination params
     * @returns {Promise<RateLimitedResponse<PaginationResponse & {orders: Array<GetOrderResponse>}>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-orders-get
     *
     * @example
     * await client.marketplace().getOrders({
     *     status: "Cancelled (Per Buyer's Request)",
     *     created_after: '2019-06-24T20:58:58Z',
     *     created_before: '2019-06-25T20:58:58Z',
     *     archived: true,
     *     sort: 'last_activity',
     *     sort_order: 'desc',
     *     page: 2,
     *     per_page: 50,
     * });
     */
    getOrders: function(params) {
      const path = `/marketplace/orders${toQueryString(params)}`;
      return client.get({ url: path, authLevel: 2 });
    },
    /**
     * Get details of a marketplace order
     * @param {number} order - The order ID
     * @returns {Promise<RateLimitedResponse<GetOrderResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-order-get
     *
     * @example
     * await client.marketplace().getOrder(1);
     */
    getOrder: function(order) {
      return client.get({ url: `/marketplace/orders/${order}`, authLevel: 2 });
    },
    /**
     * Edit a marketplace order
     * @param {number} order - The order ID
     * @param {Partial<{status: OrderStatus; shipping: number}>} data - The data for the order
     * @returns {Promise<RateLimitedResponse<GetOrderResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-order-post
     *
     * @example
     * await client.marketplace().editOrder(1, { status: 'Shipped', shipping: 10 });
     */
    editOrder: function(order, data) {
      return client.post({ url: `/marketplace/orders/${order}`, authLevel: 2 }, data);
    },
    /**
     * List the messages for the given order ID
     * @param {number} order - The order ID
     * @param {PaginationParameters} [params] - Optional pagination parameters
     * @returns {Promise<RateLimitedResponse<PaginationResponse & {messages: Array<OrderMessage>}>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages-get
     *
     * @example
     * await client.marketplace().getOrderMessages(1, { page: 2, per_page: 50 });
     */
    getOrderMessages: function(order, params) {
      const path = `/marketplace/orders/${order}/messages${toQueryString(params)}`;
      return client.get({ url: path, authLevel: 2 });
    },
    /**
     * Add a message to the given order ID
     * @param {number} order - The order ID
     * @param {Partial<{message: string; status: OrderStatus}>} data - The message data
     * @returns {Promise<RateLimitedResponse<OrderMessage>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-list-order-messages-post
     *
     * @example
     * await client.marketplace().addOrderMessage(1, { message: 'hello world', status: 'New Order' });
     */
    addOrderMessage: function(order, data) {
      return client.post({ url: "/marketplace/orders/" + order + "/messages", authLevel: 2 }, data);
    },
    /**
     * Get the marketplace fee for a given price
     * @param {number} price - The price as a number
     * @param {Currency} [currency] - Optional currency as one of USD, GBP, EUR, CAD, AUD, or JPY. Defaults to USD.
     * @returns {Promise<RateLimitedResponse<Price>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee-get
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-fee-with-currency-get
     *
     * @example
     * await client.marketplace().getFee(10);
     * await client.marketplace().getFee(10, 'EUR');
     */
    getFee: function(price, currency) {
      let path = `/marketplace/fee/${price.toFixed(2)}`;
      if (currency) {
        path += "/" + currency;
      }
      return client.get(path);
    },
    /**
     * Get price suggestions for a given release ID in the user's selling currency
     * @param {number} release - The release ID
     * @returns {Promise<RateLimitedResponse<Record<Condition, Price>>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-price-suggestions-get
     *
     * @example
     * await client.marketplace().getPriceSuggestions(10);
     */
    getPriceSuggestions: function(release) {
      return client.get({ url: `/marketplace/price_suggestions/${release}`, authLevel: 2 });
    },
    /**
     * Retrieve marketplace statistics for the provided Release ID.
     * These statistics reflect the state of the release in the marketplace currently,
     * and include the number of items currently for sale, lowest listed price of any item for sale,
     * and whether the item is blocked for sale in the marketplace.
     * @param {number} release
     * @param {Currency} [currency]
     * @returns {Promise<RateLimitedResponse<GetReleaseStatsResponseMarketplace>>}
     *
     * @see https://www.discogs.com/developers/#page:marketplace,header:marketplace-release-statistics-get
     *
     * @example
     * await client.marketplace().getReleaseStats(1, 'EUR');
     */
    getReleaseStats: function(release, currency) {
      let path = `/marketplace/stats/${release}`;
      if (currency) {
        path += `${toQueryString({ curr_abbr: currency })}`;
      }
      return client.get(path);
    }
  };
}

// lib/inventory.ts
function inventory_default(client) {
  return {
    /**
     * Request an export of your inventory as a CSV.
     * Note: this method only requests the export and doesn't return the CSV yet.
     *
     * @returns {Promise<RateLimitedResponse<void>>}
     *
     * @see https://www.discogs.com/developers#page:inventory-export,header:inventory-export-export-your-inventory-post
     *
     * @example
     * await discogs.inventory().exportInventory();
     */
    exportInventory: function() {
      const response = client.post("/inventory/export", {});
      return response.then((response2) => ({
        rateLimit: response2.rateLimit,
        data: void 0
      }));
    },
    /**
     * Get a list of all recent exports of your inventory.
     *
     * @param {PaginationParameters} [params]
     * @returns {Promise<RateLimitedResponse<GetInventoryExportsResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers#page:inventory-export,header:inventory-export-get-recent-exports-get
     *
     * @example
     * await discogs.inventory().getExports();
     */
    getExports: function(params) {
      return client.get(`/inventory/export${toQueryString(params)}`);
    },
    /**
     * Get details about the status of an inventory export.
     *
     * @param id Id of the export
     * @returns {Promise<RateLimitedResponse<GetInventoryExportsResponse & PaginationResponse>>}
     *
     * @see https://www.discogs.com/developers#page:inventory-export,header:inventory-export-get-an-export-get
     *
     * @example
     * await discogs.inventory().getExport(599632);
     */
    getExport: function(id) {
      return client.get(`/inventory/export/${id}`);
    },
    /**
     * Get details about the status of an inventory export. Returns the raw Response in `data`,
     * see the example below for further details.
     *
     * @param id Id of the export
     * @returns {Promise<RateLimitedResponse<Response>>}
     *
     * @see https://www.discogs.com/developers#page:inventory-export,header:inventory-export-download-an-export-get
     *
     * @example
     * // Node.js example; download an export, and save it to a file named 'export.csv'
     * import fs from 'fs';
     * import { pipeline } from 'stream/promises';
     *
     * const response = await discogs.inventory().downloadExport(4647524);
     * const writeStream = fs.createWriteStream('export.csv');
     * await pipeline(response.data.body, writeStream);
     */
    downloadExport: function(id) {
      return client.get({ url: `/inventory/export/${id}/download`, json: false });
    }
  };
}

// lib/oauth.ts
import fetch from "node-fetch";
import * as crypto from "crypto";
var version = "4.1.2";
var homepage = "https://github.com/lionralfs/discogs-client";
var userAgent = `@lionralfs/discogs-client/${version} +${homepage}`;
var DiscogsOAuth = class {
  /**
   * @param {string} consumerKey - The Discogs consumer key
   * @param {string} consumerSecret - The Discogs consumer secret
   */
  constructor(consumerKey, consumerSecret) {
    this.consumerKey = consumerKey;
    this.consumerSecret = consumerSecret;
  }
  /**
   * Get an OAuth request token from Discogs
   */
  async getRequestToken(callbackUrl) {
    const consumerKey = this.consumerKey;
    const consumerSecret = this.consumerSecret;
    const timestamp = Date.now();
    const nonce = crypto.randomBytes(64).toString("hex");
    const resp = await fetch("https://api.discogs.com/oauth/request_token", {
      method: "GET",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `OAuth oauth_consumer_key="${consumerKey}", oauth_nonce="${nonce}", oauth_signature="${consumerSecret}&", oauth_signature_method="PLAINTEXT", oauth_timestamp="${timestamp}", oauth_callback="${encodeURIComponent(
          callbackUrl
        )}"`,
        "User-Agent": userAgent
      }
    });
    if (resp.status !== 200) {
      let message = "Unknown Error.";
      try {
        message = await resp.text();
      } catch (_) {
      }
      throw new DiscogsError(resp.status, message);
    }
    const responseBody = await resp.text();
    const searchParams = new URLSearchParams(responseBody);
    const token = searchParams.get("oauth_token");
    return {
      token,
      tokenSecret: searchParams.get("oauth_token_secret"),
      callbackConfirmed: searchParams.get("oauth_callback_confirmed") === "true",
      authorizeUrl: `https://discogs.com/oauth/authorize?oauth_token=${token}`
    };
  }
  /**
   * Get an OAuth access token from Discogs
   * @param {string} token
   * @param {string} tokenSecret
   * @param {string} verifier - The OAuth 1.0a verification code returned by Discogs
   */
  async getAccessToken(token, tokenSecret, verifier) {
    const consumerKey = this.consumerKey;
    const consumerSecret = this.consumerSecret;
    const timestamp = Date.now();
    const nonce = crypto.randomBytes(64).toString("hex");
    const resp = await fetch("https://api.discogs.com/oauth/access_token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        Authorization: `OAuth oauth_consumer_key="${consumerKey}", oauth_nonce="${nonce}", oauth_token="${token}", oauth_signature="${consumerSecret}&${tokenSecret}", oauth_signature_method="PLAINTEXT", oauth_timestamp="${timestamp}", oauth_verifier="${verifier}"`,
        "User-Agent": userAgent
      }
    });
    if (resp.status !== 200) {
      let message = "Unknown Error.";
      try {
        message = await resp.text();
      } catch (_) {
      }
      throw new DiscogsError(resp.status, message);
    }
    const responseBody = await resp.text();
    const searchParams = new URLSearchParams(responseBody);
    return {
      accessToken: searchParams.get("oauth_token"),
      accessTokenSecret: searchParams.get("oauth_token_secret")
    };
  }
};
function toAuthHeader(consumerKey, consumerSecret, accessToken, accessTokenSecret, clock, _crypto) {
  const nonce = _crypto.randomBytes(32).toString("hex", 0, 64);
  const timestamp = Math.floor(clock.now() / 1e3);
  return `OAuth oauth_consumer_key="${consumerKey}", oauth_token="${accessToken}", oauth_signature_method="PLAINTEXT", oauth_signature="${consumerSecret}&${accessTokenSecret}", oauth_timestamp="${timestamp}", oauth_nonce="${nonce}", oauth_token_secret="${accessTokenSecret}", oauth_version="1.0"`;
}

// lib/helpers-internal.ts
function hasProperty(obj, prop) {
  return typeof obj === "object" && obj !== null && prop in obj;
}

// lib/client.ts
import * as crypto2 from "crypto";
var version2 = "4.1.2";
var homepage2 = "https://github.com/lionralfs/discogs-client";
var userAgent2 = `@lionralfs/discogs-client/${version2} +${homepage2}`;
var defaultConfig = {
  host: "api.discogs.com",
  port: 443,
  userAgent: userAgent2,
  apiVersion: "v2",
  // Possible values: 'discogs' / 'plaintext' / 'html'
  outputFormat: "discogs",
  exponentialBackoffMaxRetries: 0,
  exponentialBackoffIntervalMs: 2e3,
  exponentialBackoffRate: 2.7
};
var DiscogsClient = class {
  /**
   * @param {Partial<{userAgent: string; auth: Partial<Auth>}>} [options]
   */
  constructor(options = {}) {
    /**
     * Test authentication by getting the identity resource for the authenticated user
     * @returns {Promise<RateLimitedResponse<GetIdentityResponse>>}
     *
     * @see https://www.discogs.com/developers/#page:user-identity,header:user-identity-identity-get
     *
     * @example
     * await client.user().getIdentity();
     */
    this.getIdentity = () => {
      return this.get({ url: "/oauth/identity", authLevel: 2 });
    };
    this.config = Object.assign({}, defaultConfig);
    if (typeof options.userAgent === "string") {
      this.config.userAgent = options.userAgent;
    }
    this.auth = void 0;
    if (typeof options.auth === "object") {
      this.auth = {};
      const auth = Object.assign({}, options.auth);
      if (!Object.prototype.hasOwnProperty.call(auth, "method")) {
        this.auth.method = "discogs";
      } else {
        this.auth.method = auth.method;
      }
      if (!Object.prototype.hasOwnProperty.call(auth, "level")) {
        if (auth.userToken) {
          this.auth.userToken = auth.userToken;
          this.auth.level = 2;
        } else if (auth.consumerKey && auth.consumerSecret) {
          this.auth.consumerKey = auth.consumerKey;
          this.auth.consumerSecret = auth.consumerSecret;
          if (auth.accessToken && auth.accessTokenSecret) {
            this.auth.accessToken = auth.accessToken;
            this.auth.accessTokenSecret = auth.accessTokenSecret;
            this.auth.level = 2;
          } else {
            this.auth.level = 1;
          }
        }
      }
    }
  }
  /**
   * Override the default configuration
   * @param {Partial<ClientConfig>} customConfig - Custom configuration object
   * @returns {DiscogsClient}
   */
  setConfig(customConfig) {
    merge(this.config, customConfig);
    return this;
  }
  /**
   * Return whether the client is authenticated for the optionally given access level
   * @param {number} [level] - Optional authentication level
   * @returns {boolean}
   */
  authenticated(level = 0) {
    return typeof this.auth === "object" && this.auth.level !== void 0 && this.auth.level >= level;
  }
  /**
   * Get info about the Discogs API and this client
   *
   * @returns {Promise<RateLimitedResponse<AboutResponse>>}
   */
  async about() {
    const clientInfo = {
      version: version2,
      userAgent: this.config.userAgent,
      authMethod: this.auth ? this.auth.method : "none",
      authLevel: this.auth ? this.auth.level : 0
    };
    const aboutResponse = await this.get("");
    aboutResponse.data.clientInfo = clientInfo;
    return aboutResponse;
  }
  /**
   * Send a raw request
   * @param {RequestOptions} options - Request options
   * {
   *		url: '', // May be a relative path when accessing the discogs API
   *		method: '', // Defaults to GET
   *		data: {} // POST/PUT data as an object
   * }
   * @param {RequestCallback} callback - Callback function receiving the data
   * @param {number} failedAttempts The amounts of times this request has been attempted but failed
   */
  rawRequest(options, callback, failedAttempts = 0) {
    const data = options.data || null;
    const method = options.method || "GET";
    const requestURL = new URL(options.url, `https://${this.config.host}`);
    requestURL.port = this.config.port.toString();
    const headers = new Headers({
      "User-Agent": this.config.userAgent,
      Accept: `application/vnd.discogs.${this.config.apiVersion}.${this.config.outputFormat}+json`
    });
    const requestOptions = {
      method,
      headers
    };
    if (data) {
      if (typeof data === "object") {
        requestOptions.body = JSON.stringify(data);
      }
      headers.set("Content-Type", "application/json");
    }
    if (this.auth && (this.auth.consumerKey || this.auth.userToken)) {
      let authHeader = "";
      if (this.auth.method === "oauth") {
        authHeader = toAuthHeader(
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.auth.consumerKey,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.auth.consumerSecret,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.auth.accessToken,
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          this.auth.accessTokenSecret,
          { now: () => Date.now() },
          crypto2
        );
      } else if (this.auth.method === "discogs") {
        authHeader = "Discogs";
        if (this.auth.userToken) {
          authHeader += " token=" + this.auth.userToken;
        } else if (this.auth.consumerKey) {
          authHeader += " key=" + this.auth.consumerKey + ", secret=" + this.auth.consumerSecret;
        }
      }
      headers.set("Authorization", authHeader);
    }
    fetch2(requestURL.toString(), requestOptions).then(async (res) => {
      const statusCode = res.status;
      if (statusCode === 429) {
        if (failedAttempts < this.config.exponentialBackoffMaxRetries) {
          const waitMs = this.config.exponentialBackoffIntervalMs * Math.pow(this.config.exponentialBackoffRate, failedAttempts);
          setTimeout(() => {
            this.rawRequest(options, callback, failedAttempts + 1);
          }, waitMs);
          return;
        }
      }
      let rateLimit = void 0;
      let err = void 0;
      if (res.headers.get("x-discogs-ratelimit")) {
        rateLimit = {
          limit: Number(res.headers.get("x-discogs-ratelimit")),
          used: Number(res.headers.get("x-discogs-ratelimit-used")),
          remaining: Number(res.headers.get("x-discogs-ratelimit-remaining"))
        };
      }
      let data2;
      if (options.json) {
        data2 = await res.json().catch(
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          () => {
          }
        );
      } else {
        data2 = res;
      }
      if (statusCode > 399) {
        const message = hasProperty(data2, "message") && typeof data2.message === "string" ? data2.message : "";
        err = new DiscogsError(statusCode, message);
      }
      callback(err, data2, rateLimit);
    }).catch((err) => {
      callback(err);
    });
  }
  /**
   * Send a request and parse text response to JSON
   * @param {RequestOptions} options - Request options
   * @returns {Promise<{data: unknown; rateLimit?: RateLimit}>}
   */
  async request(options) {
    if (!Object.prototype.hasOwnProperty.call(options, "json")) {
      options.json = true;
    }
    return new Promise((resolve, reject) => {
      const doRequest = () => {
        this.rawRequest(options, function(err, data, rateLimit) {
          if (err) return reject(err);
          resolve({ data, rateLimit });
        });
      };
      if (options.authLevel && !this.authenticated(options.authLevel)) {
        throw new AuthError();
      }
      doRequest();
    });
  }
  /**
   * Perform a GET request against the Discogs API
   *
   * @param {string | RequestOptions} options - Request options object or an url
   */
  get(options) {
    if (typeof options === "string") {
      options = { url: options };
    }
    return this.request(options);
  }
  /**
   * Perform a POST request against the Discogs API
   * @param {string | RequestOptions} options - Request options object or an url
   * @param {RequestOptions['data']} data - POST data
   * @returns {Promise<unknown>}
   */
  post(options, data) {
    if (typeof options === "string") {
      options = { url: options };
    }
    options.method = "POST";
    options.data = data;
    return this.request(options);
  }
  /**
   * Perform a PUT request against the Discogs API
   * @param {string | RequestOptions} options - Request options object or an url
   * @param {RequestOptions['data']} data - PUT data
   * @returns {Promise<unknown>}
   */
  put(options, data) {
    if (typeof options === "string") {
      options = { url: options };
    }
    options.method = "PUT";
    options.data = data;
    return this.request(options);
  }
  /**
   * Perform a DELETE request against the Discogs API
   * @param {string | RequestOptions} options - Request options object or an url
   * @returns {Promise<unknown>}
   */
  delete(options) {
    if (typeof options === "string") {
      options = { url: options };
    }
    options.method = "DELETE";
    return this.request(options);
  }
  /**
   * Expose the database functions and pass the current instance
   * @returns {ReturnType<typeof database>}
   */
  database() {
    return database_default(this);
  }
  /**
   * Expose the marketplace functions and pass the current instance
   * @returns {ReturnType<typeof marketplace>}
   */
  marketplace() {
    return marketplace_default(this);
  }
  /**
   * Exposes the interface to interact with one's inventory (import/export)
   * @returns {ReturnType<inventory>}
   */
  inventory() {
    return inventory_default(this);
  }
  /**
   * Expose the user functions and pass the current instance
   * @returns {ReturnType<typeof user>}
   */
  user() {
    return user_default(this);
  }
};
export {
  DiscogsClient,
  DiscogsOAuth,
  escape,
  merge,
  stripVariation,
  toQueryString
};
